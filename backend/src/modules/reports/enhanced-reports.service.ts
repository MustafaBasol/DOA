import { PrismaClient } from '@prisma/client';
import * as ExcelJS from 'exceljs';
import PDFDocument from 'pdfkit';

const prisma = new PrismaClient();

export interface ReportFilters {
  userId?: string;
  startDate?: Date;
  endDate?: Date;
  status?: string;
}

export class EnhancedReportsService {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  /**
   * Generate comprehensive analytics report (PDF)
   */
  async generateAnalyticsReportPDF(filters: ReportFilters): Promise<Buffer> {
    const doc = new PDFDocument({ size: 'A4', margin: 50 });
    const chunks: Buffer[] = [];

    doc.on('data', (chunk) => chunks.push(chunk));

    // Header
    doc
      .fontSize(24)
      .font('Helvetica-Bold')
      .text('DOA Analytics Report', { align: 'center' })
      .moveDown();

    doc
      .fontSize(10)
      .font('Helvetica')
      .text(`Report Generated: ${new Date().toLocaleString('tr-TR')}`, { align: 'center' })
      .moveDown(2);

    // Date range
    if (filters.startDate || filters.endDate) {
      doc.fontSize(12).font('Helvetica-Bold').text('Report Period:', { underline: true });
      if (filters.startDate) {
        doc
          .fontSize(10)
          .font('Helvetica')
          .text(`From: ${filters.startDate.toLocaleDateString('tr-TR')}`);
      }
      if (filters.endDate) {
        doc.text(`To: ${filters.endDate.toLocaleDateString('tr-TR')}`);
      }
      doc.moveDown();
    }

    // Messages Statistics
    const messageStats = await this.getMessageStatistics(filters);
    this.addSectionToPDF(doc, 'Message Statistics', messageStats);

    // Payment Statistics
    const paymentStats = await this.getPaymentStatistics(filters);
    this.addSectionToPDF(doc, 'Payment Statistics', paymentStats);

    // Subscription Statistics
    const subscriptionStats = await this.getSubscriptionStatistics(filters);
    this.addSectionToPDF(doc, 'Subscription Statistics', subscriptionStats);

    // User Activity
    const userActivity = await this.getUserActivityStats(filters);
    this.addSectionToPDF(doc, 'User Activity', userActivity);

    // Footer
    doc
      .moveDown(3)
      .fontSize(8)
      .text('Generated by DOA WhatsApp Manager System', { align: 'center' })
      .text('Â© 2026 Autoviseo. All rights reserved.', { align: 'center' });

    doc.end();

    return new Promise((resolve, reject) => {
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);
    });
  }

  /**
   * Generate payment summary report (Excel)
   */
  async generatePaymentSummaryExcel(filters: ReportFilters): Promise<Buffer> {
    const workbook = new ExcelJS.Workbook();
    workbook.creator = 'DOA System';
    workbook.created = new Date();

    // Summary Sheet
    const summarySheet = workbook.addWorksheet('Payment Summary', {
      properties: { tabColor: { argb: 'FF00FF00' } },
    });

    const payments = await this.prisma.payment.findMany({
      where: this.buildPaymentWhere(filters),
      include: {
        user: {
          select: {
            id: true,
            fullName: true,
            companyName: true,
            email: true,
          },
        },
        subscription: {
          select: {
            id: true,
            planName: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    // Calculate statistics
    const stats = this.calculatePaymentStats(payments);

    // Add summary data
    summarySheet.columns = [
      { header: 'Metric', key: 'metric', width: 30 },
      { header: 'Value', key: 'value', width: 20 },
    ];

    summarySheet.addRows([
      { metric: 'Total Payments', value: stats.total },
      { metric: 'Completed', value: stats.completed },
      { metric: 'Pending', value: stats.pending },
      { metric: 'Failed', value: stats.failed },
      { metric: 'Total Revenue (TRY)', value: stats.totalRevenue.toFixed(2) },
      { metric: 'Average Payment (TRY)', value: stats.averagePayment.toFixed(2) },
      { metric: 'Report Date', value: new Date().toLocaleString('tr-TR') },
    ]);

    this.styleHeaderRow(summarySheet, 'FF10B981');

    // Detail Sheet
    const detailSheet = workbook.addWorksheet('Payment Details');
    detailSheet.columns = [
      { header: 'Date', key: 'date', width: 20 },
      { header: 'User', key: 'user', width: 25 },
      { header: 'Plan', key: 'plan', width: 20 },
      { header: 'Amount', key: 'amount', width: 15 },
      { header: 'Currency', key: 'currency', width: 10 },
      { header: 'Method', key: 'method', width: 15 },
      { header: 'Status', key: 'status', width: 12 },
    ];

    payments.forEach((payment: any) => {
      detailSheet.addRow({
        date: payment.createdAt.toLocaleString('tr-TR'),
        user: payment.user?.companyName || payment.user?.fullName || 'N/A',
        plan: payment.subscription?.planName || 'N/A',
        amount: parseFloat(payment.amount.toString()),
        currency: payment.currency,
        method: payment.paymentMethod || 'N/A',
        status: payment.status,
      });
    });

    this.styleHeaderRow(detailSheet, 'FF3B82F6');
    detailSheet.autoFilter = {
      from: { row: 1, column: 1 },
      to: { row: 1, column: 7 },
    };

    // Monthly Summary Sheet
    const monthlySheet = workbook.addWorksheet('Monthly Breakdown');
    const monthlyData = this.groupPaymentsByMonth(payments);

    monthlySheet.columns = [
      { header: 'Month', key: 'month', width: 20 },
      { header: 'Total Payments', key: 'total', width: 15 },
      { header: 'Completed', key: 'completed', width: 15 },
      { header: 'Revenue (TRY)', key: 'revenue', width: 20 },
    ];

    monthlyData.forEach((data) => {
      monthlySheet.addRow(data);
    });

    this.styleHeaderRow(monthlySheet, 'FFEF4444');

    const buffer = await workbook.xlsx.writeBuffer();
    return Buffer.from(buffer);
  }

  /**
   * Generate subscription expiry report (Excel)
   */
  async generateSubscriptionExpiryReport(): Promise<Buffer> {
    const workbook = new ExcelJS.Workbook();
    const sheet = workbook.addWorksheet('Expiring Subscriptions');

    const now = new Date();
    const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);

    const subscriptions = await this.prisma.subscription.findMany({
      where: {
        status: 'ACTIVE',
        endDate: {
          gte: now,
          lte: thirtyDaysFromNow,
        },
      },
      include: {
        user: {
          select: {
            id: true,
            fullName: true,
            companyName: true,
            email: true,
            phone: true,
          },
        },
      },
      orderBy: { endDate: 'asc' },
    });

    sheet.columns = [
      { header: 'User', key: 'user', width: 25 },
      { header: 'Email', key: 'email', width: 30 },
      { header: 'Phone', key: 'phone', width: 20 },
      { header: 'Plan', key: 'plan', width: 20 },
      { header: 'Price (TRY)', key: 'price', width: 15 },
      { header: 'End Date', key: 'endDate', width: 20 },
      { header: 'Days Left', key: 'daysLeft', width: 12 },
      { header: 'Auto Renew', key: 'autoRenew', width: 12 },
    ];

    subscriptions.forEach((sub: any) => {
      const daysLeft = Math.ceil((sub.endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
      sheet.addRow({
        user: sub.user?.companyName || sub.user?.fullName || 'N/A',
        email: sub.user?.email || 'N/A',
        phone: sub.user?.phone || 'N/A',
        plan: sub.planName,
        price: parseFloat(sub.monthlyPrice.toString()),
        endDate: sub.endDate.toLocaleDateString('tr-TR'),
        daysLeft,
        autoRenew: sub.autoRenew ? 'Yes' : 'No',
      });
    });

    this.styleHeaderRow(sheet, 'FFF59E0B');

    // Add conditional formatting for days left
    sheet.getColumn('daysLeft').eachCell((cell, rowNumber) => {
      if (rowNumber > 1) {
        const value = cell.value as number;
        if (value <= 7) {
          cell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFFECACA' },
          };
        } else if (value <= 14) {
          cell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFFEF3C7' },
          };
        }
      }
    });

    const buffer = await workbook.xlsx.writeBuffer();
    return Buffer.from(buffer);
  }

  /**
   * Generate user activity report (Excel)
   */
  async generateUserActivityReport(filters: ReportFilters): Promise<Buffer> {
    const workbook = new ExcelJS.Workbook();
    const sheet = workbook.addWorksheet('User Activity');

    const where: any = {};
    if (filters.startDate || filters.endDate) {
      where.createdAt = {};
      if (filters.startDate) where.createdAt.gte = filters.startDate;
      if (filters.endDate) where.createdAt.lte = filters.endDate;
    }

    const users = await this.prisma.user.findMany({
      where,
      select: {
        id: true,
        fullName: true,
        companyName: true,
        email: true,
        role: true,
        isActive: true,
        lastLogin: true,
        createdAt: true,
        _count: {
          select: {
            messages: true,
            payments: true,
            subscriptions: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    sheet.columns = [
      { header: 'User', key: 'user', width: 25 },
      { header: 'Email', key: 'email', width: 30 },
      { header: 'Role', key: 'role', width: 15 },
      { header: 'Status', key: 'status', width: 10 },
      { header: 'Messages', key: 'messages', width: 12 },
      { header: 'Payments', key: 'payments', width: 12 },
      { header: 'Subscriptions', key: 'subscriptions', width: 15 },
      { header: 'Last Login', key: 'lastLogin', width: 20 },
      { header: 'Registered', key: 'registered', width: 20 },
    ];

    users.forEach((user) => {
      sheet.addRow({
        user: user.companyName || user.fullName || 'N/A',
        email: user.email,
        role: user.role,
        status: user.isActive ? 'Active' : 'Inactive',
        messages: user._count.messages,
        payments: user._count.payments,
        subscriptions: user._count.subscriptions,
        lastLogin: user.lastLogin ? user.lastLogin.toLocaleString('tr-TR') : 'Never',
        registered: user.createdAt.toLocaleString('tr-TR'),
      });
    });

    this.styleHeaderRow(sheet, 'FF8B5CF6');
    sheet.autoFilter = {
      from: { row: 1, column: 1 },
      to: { row: 1, column: 9 },
    };

    const buffer = await workbook.xlsx.writeBuffer();
    return Buffer.from(buffer);
  }

  // Helper Methods
  private addSectionToPDF(doc: any, title: string, data: any) {
    doc
      .moveDown()
      .fontSize(14)
      .font('Helvetica-Bold')
      .text(title, { underline: true })
      .moveDown(0.5);

    doc.fontSize(10).font('Helvetica');

    Object.entries(data).forEach(([key, value]) => {
      const label = key
        .replace(/([A-Z])/g, ' $1')
        .replace(/^./, (str) => str.toUpperCase());
      doc.text(`${label}: ${value}`);
    });

    doc.moveDown();
  }

  private async getMessageStatistics(filters: ReportFilters) {
    const where = this.buildMessageWhere(filters);

    const [total, inbound, outbound, read, unread] = await Promise.all([
      prisma.whatsappMessage.count({ where }),
      prisma.whatsappMessage.count({ where: { ...where, direction: 'INBOUND' } }),
      prisma.whatsappMessage.count({ where: { ...where, direction: 'OUTBOUND' } }),
      prisma.whatsappMessage.count({ where: { ...where, readStatus: true } }),
      prisma.whatsappMessage.count({ where: { ...where, readStatus: false } }),
    ]);

    return {
      totalMessages: total,
      inboundMessages: inbound,
      outboundMessages: outbound,
      readMessages: read,
      unreadMessages: unread,
      readRate: total > 0 ? `${((read / total) * 100).toFixed(1)}%` : '0%',
    };
  }

  private async getPaymentStatistics(filters: ReportFilters) {
    const where = this.buildPaymentWhere(filters);

    const [payments, completed, pending, failed] = await Promise.all([
      prisma.payment.findMany({ where }),
      prisma.payment.count({ where: { ...where, status: 'COMPLETED' } }),
      prisma.payment.count({ where: { ...where, status: 'PENDING' } }),
      prisma.payment.count({ where: { ...where, status: 'FAILED' } }),
    ]);

    const totalRevenue = payments
      .filter((p: any) => p.status === 'COMPLETED')
      .reduce((sum, p: any) => sum + parseFloat(p.amount.toString()), 0);

    return {
      totalPayments: payments.length,
      completedPayments: completed,
      pendingPayments: pending,
      failedPayments: failed,
      totalRevenue: `${totalRevenue.toFixed(2)} TRY`,
      averagePayment: payments.length > 0 ? `${(totalRevenue / completed).toFixed(2)} TRY` : '0 TRY',
    };
  }

  private async getSubscriptionStatistics(filters: ReportFilters) {
    const where = this.buildSubscriptionWhere(filters);

    const [total, active, cancelled] = await Promise.all([
      prisma.subscription.count({ where }),
      prisma.subscription.count({ where: { ...where, status: 'ACTIVE' } }),
      prisma.subscription.count({ where: { ...where, status: 'CANCELLED' } }),
    ]);

    return {
      totalSubscriptions: total,
      activeSubscriptions: active,
      cancelledSubscriptions: cancelled,
      retentionRate: total > 0 ? `${((active / total) * 100).toFixed(1)}%` : '0%',
    };
  }

  private async getUserActivityStats(filters: ReportFilters) {
    const where: any = {};
    if (filters.startDate || filters.endDate) {
      where.createdAt = {};
      if (filters.startDate) where.createdAt.gte = filters.startDate;
      if (filters.endDate) where.createdAt.lte = filters.endDate;
    }

    const [total, active, admins, clients] = await Promise.all([
      prisma.user.count({ where }),
      prisma.user.count({ where: { ...where, isActive: true } }),
      prisma.user.count({ where: { ...where, role: { in: ['SUPER_ADMIN', 'ADMIN'] } } }),
      prisma.user.count({ where: { ...where, role: 'CLIENT' } }),
    ]);

    return {
      totalUsers: total,
      activeUsers: active,
      adminUsers: admins,
      clientUsers: clients,
    };
  }

  private buildMessageWhere(filters: ReportFilters) {
    const where: any = {};
    if (filters.userId) where.userId = filters.userId;
    if (filters.startDate || filters.endDate) {
      where.timestamp = {};
      if (filters.startDate) where.timestamp.gte = filters.startDate;
      if (filters.endDate) where.timestamp.lte = filters.endDate;
    }
    return where;
  }

  private buildPaymentWhere(filters: ReportFilters) {
    const where: any = {};
    if (filters.userId) where.userId = filters.userId;
    if (filters.status) where.status = filters.status;
    if (filters.startDate || filters.endDate) {
      where.createdAt = {};
      if (filters.startDate) where.createdAt.gte = filters.startDate;
      if (filters.endDate) where.createdAt.lte = filters.endDate;
    }
    return where;
  }

  private buildSubscriptionWhere(filters: ReportFilters) {
    const where: any = {};
    if (filters.userId) where.userId = filters.userId;
    if (filters.status) where.status = filters.status;
    if (filters.startDate || filters.endDate) {
      where.createdAt = {};
      if (filters.startDate) where.createdAt.gte = filters.startDate;
      if (filters.endDate) where.createdAt.lte = filters.endDate;
    }
    return where;
  }

  private calculatePaymentStats(payments: any[]) {
    const completed = payments.filter((p) => p.status === 'COMPLETED');
    const totalRevenue = completed.reduce((sum, p) => sum + parseFloat(p.amount.toString()), 0);

    return {
      total: payments.length,
      completed: completed.length,
      pending: payments.filter((p) => p.status === 'PENDING').length,
      failed: payments.filter((p) => p.status === 'FAILED').length,
      totalRevenue,
      averagePayment: completed.length > 0 ? totalRevenue / completed.length : 0,
    };
  }

  private groupPaymentsByMonth(payments: any[]) {
    const monthlyData = new Map<string, any>();

    payments.forEach((payment) => {
      const month = payment.createdAt.toLocaleString('tr-TR', { year: 'numeric', month: 'long' });
      if (!monthlyData.has(month)) {
        monthlyData.set(month, { month, total: 0, completed: 0, revenue: 0 });
      }

      const data = monthlyData.get(month)!;
      data.total++;
      if (payment.status === 'COMPLETED') {
        data.completed++;
        data.revenue += parseFloat(payment.amount.toString());
      }
    });

    return Array.from(monthlyData.values());
  }

  private styleHeaderRow(sheet: ExcelJS.Worksheet, color: string) {
    sheet.getRow(1).font = { bold: true, color: { argb: 'FFFFFFFF' } };
    sheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: color },
    };
    sheet.getRow(1).alignment = { vertical: 'middle', horizontal: 'center' };
  }
}

export const enhancedReportsService = new EnhancedReportsService();
